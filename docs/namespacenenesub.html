<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nenesub: nenesub Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">nenesub
   </div>
   <div id="projectbrief">Nearest neighbors subsampling</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">nenesub Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Nearest-neighbors subsampling.  
<a href="namespacenenesub.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnenesub_1_1Options.html">Options</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnenesub_1_1Options.html" title="Options for compute().">Options</a> for <code><a class="el" href="namespacenenesub.html#a38e855459f3bf52b4248a40e73a27129">compute()</a></code>.  <a href="structnenesub_1_1Options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a38e855459f3bf52b4248a40e73a27129" id="r_a38e855459f3bf52b4248a40e73a27129"><td class="memTemplParams" colspan="2">template&lt;typename Index_ , class GetNeighbors_ , class GetIndex_ , class GetMaxDistance_ &gt; </td></tr>
<tr class="memitem:a38e855459f3bf52b4248a40e73a27129"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenenesub.html#a38e855459f3bf52b4248a40e73a27129">compute</a> (Index_ num_obs, GetNeighbors_ get_neighbors, GetIndex_ get_index, GetMaxDistance_ get_max_distance, const <a class="el" href="structnenesub_1_1Options.html">Options</a> &amp;options, std::vector&lt; Index_ &gt; &amp;selected)</td></tr>
<tr class="separator:a38e855459f3bf52b4248a40e73a27129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8fc59d26d84d5726dd8fe0b845c690" id="r_a0f8fc59d26d84d5726dd8fe0b845c690"><td class="memTemplParams" colspan="2">template&lt;typename Index_ , typename Distance_ &gt; </td></tr>
<tr class="memitem:a0f8fc59d26d84d5726dd8fe0b845c690"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Index_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenenesub.html#a0f8fc59d26d84d5726dd8fe0b845c690">compute</a> (const <a class="elRef" href="https://knncolle.github.io/knncolle/namespaceknncolle.html#a25d7a950cf7745b99bc834b79e064c09">knncolle::NeighborList</a>&lt; Index_, Distance_ &gt; &amp;neighbors, const <a class="el" href="structnenesub_1_1Options.html">Options</a> &amp;options)</td></tr>
<tr class="separator:a0f8fc59d26d84d5726dd8fe0b845c690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9690e9944c27045dfed80989191fc842" id="r_a9690e9944c27045dfed80989191fc842"><td class="memTemplParams" colspan="2">template&lt;typename Dim_ , typename Index_ , typename Float_ &gt; </td></tr>
<tr class="memitem:a9690e9944c27045dfed80989191fc842"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Index_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenenesub.html#a9690e9944c27045dfed80989191fc842">compute</a> (const <a class="elRef" href="https://knncolle.github.io/knncolle/classknncolle_1_1Prebuilt.html">knncolle::Prebuilt</a>&lt; Dim_, Index_, Float_ &gt; &amp;prebuilt, const <a class="el" href="structnenesub_1_1Options.html">Options</a> &amp;options)</td></tr>
<tr class="separator:a9690e9944c27045dfed80989191fc842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b97f1e543d9932e4a31d6ade6acb51" id="r_a19b97f1e543d9932e4a31d6ade6acb51"><td class="memTemplParams" colspan="2">template&lt;typename Dim_ , typename Index_ , typename Value_ , typename Float_ &gt; </td></tr>
<tr class="memitem:a19b97f1e543d9932e4a31d6ade6acb51"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Index_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenenesub.html#a19b97f1e543d9932e4a31d6ade6acb51">compute</a> (Dim_ num_dims, Index_ num_obs, const Value_ *data, const <a class="elRef" href="https://knncolle.github.io/knncolle/classknncolle_1_1Builder.html">knncolle::Builder</a>&lt; <a class="elRef" href="https://knncolle.github.io/knncolle/classknncolle_1_1SimpleMatrix.html">knncolle::SimpleMatrix</a>&lt; Dim_, Index_, Value_ &gt;, Float_ &gt; &amp;knn_method, const <a class="el" href="structnenesub_1_1Options.html">Options</a> &amp;options)</td></tr>
<tr class="separator:a19b97f1e543d9932e4a31d6ade6acb51"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Nearest-neighbors subsampling. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a38e855459f3bf52b4248a40e73a27129" name="a38e855459f3bf52b4248a40e73a27129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38e855459f3bf52b4248a40e73a27129">&#9670;&#160;</a></span>compute() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index_ , class GetNeighbors_ , class GetIndex_ , class GetMaxDistance_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void nenesub::compute </td>
          <td>(</td>
          <td class="paramtype">Index_&#160;</td>
          <td class="paramname"><em>num_obs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GetNeighbors_&#160;</td>
          <td class="paramname"><em>get_neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GetIndex_&#160;</td>
          <td class="paramname"><em>get_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GetMaxDistance_&#160;</td>
          <td class="paramname"><em>get_max_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnenesub_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Index_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function generates a deterministic subsampling of a dataset based on nearest neighbors. We first identify the \(k\)-nearest neighbors of each observation and use that to define its local neighborhood. We select an observation for subsampling if it:</p>
<ul>
<li>Does not belong in the local neighborhood of any previously selected observation.</li>
<li>Has the most neighbors that are not selected or in the local neighborhoods of previously selected observations. Ties are broken using the smallest distance to each observation's \(k\)-th neighbor (i.e., the densest region of space).</li>
<li>Has at least \(m\) neighbors that are not selected or in the local neighborhoods of any other selected observation.</li>
</ul>
<p>We repeat this process until there are no more observations that satisfy these requirements.</p>
<p>Each selected observation effectively serves as a representative for up to \(k\) of its nearest neighbors. As such, the rate of subsampling is roughly proportional to the choice of \(k\). A non-zero \(m\) ensures that there are enough neighbors to warrant the selection of an observation, to protect against overrepresentation of outlier points that are not in any observation's neighborhood. Some testing suggests that the dataset is subsampled by a factor of \(k\), though this can increase or decrease for smaller or larger \(m\), respectively.</p>
<p>The <b>nenesub</b> approach ensures that the subsampled points are well-distributed across the dataset. Low-frequency subpopulations will always have at least a few representatives if they are sufficiently distant from other subpopulations. In contrast, random sampling does not provide strong guarantees for capture of a rare subpopulation. We also preserve the relative density across the dataset as more representatives will be generated from high-density regions. This simplifies the interpretation of analysis results generated from the subsetted dataset.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index_</td><td>Integer type for the observation indices. </td></tr>
    <tr><td class="paramname">GetNeighbors_</td><td>Function that accepts an <code>Index_</code> index and returns a (const reference to a) container-like object. The container should be support the <code>[]</code> operator and have a <code>size()</code> method. </td></tr>
    <tr><td class="paramname">GetIndex_</td><td>Function that accepts a (const reference to a) container of the type returned by <code>GetNeighbors_</code> and an <code>Index_</code> into that container, and returns <code>Index_</code>. </td></tr>
    <tr><td class="paramname">GetNeighbors_</td><td>Function that accepts an <code>Index_</code> index and returns a distance value, typically floating-point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">num_obs</td><td>Number of observations in the dataset. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">get_neighbors</td><td>Function that accepts an integer observation index in <code>[0, num_obs)</code> and returns a container of that observation's neighbors. Each element of the container specifies the index of a neighboring observation. It is generally expected that the returned containers have the same size for all indices. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">get_index</td><td>Function to return the index of each neighbor, given the container returned by <code>get_neighbors</code> and an index into that container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">get_max_distance</td><td>Function that accepts an integer observation index in <code>[0, num_obs)</code> and returns the distance from that observation to its furthest neighbor. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options. Note that <code><a class="el" href="structnenesub_1_1Options.html#a5df6fdc7c00d5560cf24e707c6d2a318">Options::num_neighbors</a></code> and <code><a class="el" href="structnenesub_1_1Options.html#a97589522562c135c803914e6e4abdecc">Options::num_threads</a></code> are ignored here. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">selected</td><td>On output, the indices of the observations that were subsampled. These are sorted in ascending order. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f8fc59d26d84d5726dd8fe0b845c690" name="a0f8fc59d26d84d5726dd8fe0b845c690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f8fc59d26d84d5726dd8fe0b845c690">&#9670;&#160;</a></span>compute() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index_ , typename Distance_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Index_ &gt; nenesub::compute </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://knncolle.github.io/knncolle/namespaceknncolle.html#a25d7a950cf7745b99bc834b79e064c09">knncolle::NeighborList</a>&lt; Index_, Distance_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnenesub_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overload to enable convenient usage with pre-computed neighbors from <b>knncolle</b>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index_</td><td>Integer type for the neighbor indices. </td></tr>
    <tr><td class="paramname">Distance_</td><td>Floating-point type for the distances.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">neighbors</td><td>Vector of nearest-neighbor search results for each observation. Each entry is a pair containing a vector of neighbor indices and a vector of distances to those neighbors. Neighbors should be sorted by increasing distance. The same number of neighbors should be present for each observation. </td></tr>
    <tr><td class="paramname">options</td><td>Further options. Note that <code><a class="el" href="structnenesub_1_1Options.html#a5df6fdc7c00d5560cf24e707c6d2a318">Options::num_neighbors</a></code> and <code><a class="el" href="structnenesub_1_1Options.html#a97589522562c135c803914e6e4abdecc">Options::num_threads</a></code> are ignored here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sorted vector of the indices of the subsampled observations. </dd></dl>

</div>
</div>
<a id="a9690e9944c27045dfed80989191fc842" name="a9690e9944c27045dfed80989191fc842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9690e9944c27045dfed80989191fc842">&#9670;&#160;</a></span>compute() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dim_ , typename Index_ , typename Float_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Index_ &gt; nenesub::compute </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://knncolle.github.io/knncolle/classknncolle_1_1Prebuilt.html">knncolle::Prebuilt</a>&lt; Dim_, Index_, Float_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>prebuilt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnenesub_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overload to enable convenient usage with a prebuilt nearest-neighbor search index from <b>knncolle</b>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Dim_</td><td>Integer type for the dimension index. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the observation index. </td></tr>
    <tr><td class="paramname">Float_</td><td>Floating-point type for the distances.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prebuilt</td><td>A prebuilt nearest-neighbor search index on the observations of interest. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sorted vector of the indices of the subsampled observations. </dd></dl>

</div>
</div>
<a id="a19b97f1e543d9932e4a31d6ade6acb51" name="a19b97f1e543d9932e4a31d6ade6acb51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19b97f1e543d9932e4a31d6ade6acb51">&#9670;&#160;</a></span>compute() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dim_ , typename Index_ , typename Value_ , typename Float_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Index_ &gt; nenesub::compute </td>
          <td>(</td>
          <td class="paramtype">Dim_&#160;</td>
          <td class="paramname"><em>num_dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_&#160;</td>
          <td class="paramname"><em>num_obs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value_ *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="https://knncolle.github.io/knncolle/classknncolle_1_1Builder.html">knncolle::Builder</a>&lt; <a class="elRef" href="https://knncolle.github.io/knncolle/classknncolle_1_1SimpleMatrix.html">knncolle::SimpleMatrix</a>&lt; Dim_, Index_, Value_ &gt;, Float_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>knn_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnenesub_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overload to enable convenient usage with a column-major array of coordinates for each observation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Dim_</td><td>Integer type for the dimension index. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the observation index. </td></tr>
    <tr><td class="paramname">Value_</td><td>Numeric type for the input data. </td></tr>
    <tr><td class="paramname">Float_</td><td>Floating-point type for the distances.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">num_dims</td><td>Number of dimensions for the observation coordinates. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">num_obs</td><td>Number of observations in the dataset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to a <code>num_dims</code>-by-<code>num_observations</code> column-major array of observation coordinates where rows are dimensions and columns are observations. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">knn_method</td><td>Specification of the nearest-neighbor search algorithm, e.g., <code><a class="elRef" href="https://knncolle.github.io/knncolle/classknncolle_1_1VptreeBuilder.html">knncolle::VptreeBuilder</a></code>, <code><a class="elRef" href="https://knncolle.github.io/knncolle/classknncolle_1_1KmknnBuilder.html">knncolle::KmknnBuilder</a></code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sorted vector of the indices of the subsampled observations. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
